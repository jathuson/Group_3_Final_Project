# -*- coding: utf-8 -*-
"""MovieRecommenderMatrixFactorization.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yRNdhhnPBpOOoOWyHP0kOG0alC4HfGAH
"""

# Matrix factorization machine learning for movie recommender system
# Template taken from https://github.com/khanhnamle1994/movielens/blob/master/SVD_Model.ipynb

# Import libraries
import numpy as np
import pandas as pd
import sqlite3 
import sqlalchemy as db

from scipy.sparse.linalg import svds

import sqlite3 
import sqlalchemy as db
from sqlalchemy import create_engine

def MovieRec(user_id): 
    # from config import db_password
    db_password = "Bootcamp_Group_3"
    # Add the code to create the connection to the PostgreSQL database, then add the movies_df DataFrame to a SQL database:
    # db_string = f"postgres://postgresql://{db_password}@127.0.0.1:5433/movie_data"
    hostname = "bootcamp-group-3.cn5djhczpkaa.us-east-1.rds.amazonaws.com"
    database = 'Bootcamp_Group_3'
    connection_string = f"postgresql://root:Bootcamp_Group_3@{hostname}/{database}"

    engine = create_engine(connection_string)

    try:
        print("Getting movies....")
        df_movies = pd.read_sql('SELECT * from "Movies" ', engine)
    
        print("Getting ratings.....")
        df_ratings = pd.read_sql('SELECT * from "Model_Refined_Data" ', engine)
        
        print("Sucess! Moving on...")
    except:
        print("ERROR! SQL STATEMENTS!")
    
    #if dataset too large, use this code to take random sample set of 40% of the original
    # ratings = ratings.sample(frac = 0.4, random_state=1)

    try:
        #Setup users and movie datasets and count the unique rows
        n_users = ratings.userId.unique().shape[0]
        n_movies = ratings.movieId.unique().shape[0]
        print ('Number of users = ' + str(n_users) + ' | Number of movies = ' + str(n_movies))

        # Create ratings matrix, each row is a unique user and each column is a movie
        Ratings = ratings.pivot(index = 'userId', columns ='movieId', values = 'rating').fillna(0)
        print("Successfully user/movie matrix")
    except:
        print("ERROR! PIVOT TABLE!")
    
    try: 
        R = Ratings.to_numpy()
        user_ratings_mean = np.mean(R, axis = 1)
        Ratings_demeaned = R - user_ratings_mean.reshape(-1, 1)

        # Checking the sparsity of the dataset
        sparsity = round(1.0 - len(ratings) / float(n_users * n_movies), 3)
        print ('The sparsity level of MovieLens1M dataset is ' +  str(sparsity * 100) + '%')

        # SVD set up
        U, sigma, Vt = svds(Ratings_demeaned, k = 50)

        # matrix form of the diagonal
        sigma = np.diag(sigma)

        all_user_predicted_ratings = np.dot(np.dot(U, sigma), Vt) + user_ratings_mean.reshape(-1, 1)

        preds = pd.DataFrame(all_user_predicted_ratings, columns = Ratings.columns)

    except:
        print("ERROR! Failed to predict ratings")

    def recommend_movies(predictions, userID, movies, original_ratings, num_recommendations):
        
        # Get and sort the user's predictions
        user_row_number = userID - 1 # User ID starts at 1, not 0
        sorted_user_predictions = preds.iloc[user_row_number].sort_values(ascending=False) # User ID starts at 1
        
        # Get the user's data and merge in the movie information.
        user_data = original_ratings[original_ratings.userId == (userID)]
        user_full = (user_data.merge(movies, how = 'left', left_on = 'movieId', right_on = 'movieId').
                        sort_values(['rating'], ascending=False)
                    )

        print ('User {0} has already rated {1} movies.'.format(userID, user_full.shape[0]))
        print ('Recommending highest {0} predicted ratings movies not already rated.'.format(num_recommendations))
        
        # Recommend the highest predicted rating movies that the user hasn't seen yet.
        recommendations = (movies[~movies['movieId'].isin(user_full['movieId'])].
            merge(pd.DataFrame(sorted_user_predictions).reset_index(), how = 'left',
                left_on = 'movieId',
                right_on = 'movieId').
            rename(columns = {user_row_number: 'Predictions'}).
            sort_values('Predictions', ascending = False).
                        iloc[:num_recommendations, :-1]
                        )

        return user_full, recommendations

    already_rated, predictions = recommend_movies(preds, user_id, movies, ratings, 20)

    return predictions